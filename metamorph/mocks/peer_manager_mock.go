// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitcoin-sv/arc/metamorph"
	"github.com/libsv/go-p2p"
	"github.com/libsv/go-p2p/chaincfg/chainhash"
	"sync"
)

// Ensure, that PeerManagerMock does implement metamorph.PeerManager.
// If this is not the case, regenerate this file with moq.
var _ metamorph.PeerManager = &PeerManagerMock{}

// PeerManagerMock is a mock implementation of metamorph.PeerManager.
//
//	func TestSomethingThatUsesPeerManager(t *testing.T) {
//
//		// make and configure a mocked metamorph.PeerManager
//		mockedPeerManager := &PeerManagerMock{
//			AddPeerFunc: func(peer p2p.PeerI) error {
//				panic("mock out the AddPeer method")
//			},
//			AnnounceBlockFunc: func(blockHash *chainhash.Hash, peers []p2p.PeerI) []p2p.PeerI {
//				panic("mock out the AnnounceBlock method")
//			},
//			AnnounceTransactionFunc: func(txHash *chainhash.Hash, peers []p2p.PeerI) []p2p.PeerI {
//				panic("mock out the AnnounceTransaction method")
//			},
//			GetPeersFunc: func() []p2p.PeerI {
//				panic("mock out the GetPeers method")
//			},
//			RequestBlockFunc: func(blockHash *chainhash.Hash) p2p.PeerI {
//				panic("mock out the RequestBlock method")
//			},
//			RequestTransactionFunc: func(txHash *chainhash.Hash) p2p.PeerI {
//				panic("mock out the RequestTransaction method")
//			},
//		}
//
//		// use mockedPeerManager in code that requires metamorph.PeerManager
//		// and then make assertions.
//
//	}
type PeerManagerMock struct {
	// AddPeerFunc mocks the AddPeer method.
	AddPeerFunc func(peer p2p.PeerI) error

	// AnnounceBlockFunc mocks the AnnounceBlock method.
	AnnounceBlockFunc func(blockHash *chainhash.Hash, peers []p2p.PeerI) []p2p.PeerI

	// AnnounceTransactionFunc mocks the AnnounceTransaction method.
	AnnounceTransactionFunc func(txHash *chainhash.Hash, peers []p2p.PeerI) []p2p.PeerI

	// GetPeersFunc mocks the GetPeers method.
	GetPeersFunc func() []p2p.PeerI

	// RequestBlockFunc mocks the RequestBlock method.
	RequestBlockFunc func(blockHash *chainhash.Hash) p2p.PeerI

	// RequestTransactionFunc mocks the RequestTransaction method.
	RequestTransactionFunc func(txHash *chainhash.Hash) p2p.PeerI

	// calls tracks calls to the methods.
	calls struct {
		// AddPeer holds details about calls to the AddPeer method.
		AddPeer []struct {
			// Peer is the peer argument value.
			Peer p2p.PeerI
		}
		// AnnounceBlock holds details about calls to the AnnounceBlock method.
		AnnounceBlock []struct {
			// BlockHash is the blockHash argument value.
			BlockHash *chainhash.Hash
			// Peers is the peers argument value.
			Peers []p2p.PeerI
		}
		// AnnounceTransaction holds details about calls to the AnnounceTransaction method.
		AnnounceTransaction []struct {
			// TxHash is the txHash argument value.
			TxHash *chainhash.Hash
			// Peers is the peers argument value.
			Peers []p2p.PeerI
		}
		// GetPeers holds details about calls to the GetPeers method.
		GetPeers []struct {
		}
		// RequestBlock holds details about calls to the RequestBlock method.
		RequestBlock []struct {
			// BlockHash is the blockHash argument value.
			BlockHash *chainhash.Hash
		}
		// RequestTransaction holds details about calls to the RequestTransaction method.
		RequestTransaction []struct {
			// TxHash is the txHash argument value.
			TxHash *chainhash.Hash
		}
	}
	lockAddPeer             sync.RWMutex
	lockAnnounceBlock       sync.RWMutex
	lockAnnounceTransaction sync.RWMutex
	lockGetPeers            sync.RWMutex
	lockRequestBlock        sync.RWMutex
	lockRequestTransaction  sync.RWMutex
}

// AddPeer calls AddPeerFunc.
func (mock *PeerManagerMock) AddPeer(peer p2p.PeerI) error {
	if mock.AddPeerFunc == nil {
		panic("PeerManagerMock.AddPeerFunc: method is nil but PeerManager.AddPeer was just called")
	}
	callInfo := struct {
		Peer p2p.PeerI
	}{
		Peer: peer,
	}
	mock.lockAddPeer.Lock()
	mock.calls.AddPeer = append(mock.calls.AddPeer, callInfo)
	mock.lockAddPeer.Unlock()
	return mock.AddPeerFunc(peer)
}

// AddPeerCalls gets all the calls that were made to AddPeer.
// Check the length with:
//
//	len(mockedPeerManager.AddPeerCalls())
func (mock *PeerManagerMock) AddPeerCalls() []struct {
	Peer p2p.PeerI
} {
	var calls []struct {
		Peer p2p.PeerI
	}
	mock.lockAddPeer.RLock()
	calls = mock.calls.AddPeer
	mock.lockAddPeer.RUnlock()
	return calls
}

// AnnounceBlock calls AnnounceBlockFunc.
func (mock *PeerManagerMock) AnnounceBlock(blockHash *chainhash.Hash, peers []p2p.PeerI) []p2p.PeerI {
	if mock.AnnounceBlockFunc == nil {
		panic("PeerManagerMock.AnnounceBlockFunc: method is nil but PeerManager.AnnounceBlock was just called")
	}
	callInfo := struct {
		BlockHash *chainhash.Hash
		Peers     []p2p.PeerI
	}{
		BlockHash: blockHash,
		Peers:     peers,
	}
	mock.lockAnnounceBlock.Lock()
	mock.calls.AnnounceBlock = append(mock.calls.AnnounceBlock, callInfo)
	mock.lockAnnounceBlock.Unlock()
	return mock.AnnounceBlockFunc(blockHash, peers)
}

// AnnounceBlockCalls gets all the calls that were made to AnnounceBlock.
// Check the length with:
//
//	len(mockedPeerManager.AnnounceBlockCalls())
func (mock *PeerManagerMock) AnnounceBlockCalls() []struct {
	BlockHash *chainhash.Hash
	Peers     []p2p.PeerI
} {
	var calls []struct {
		BlockHash *chainhash.Hash
		Peers     []p2p.PeerI
	}
	mock.lockAnnounceBlock.RLock()
	calls = mock.calls.AnnounceBlock
	mock.lockAnnounceBlock.RUnlock()
	return calls
}

// AnnounceTransaction calls AnnounceTransactionFunc.
func (mock *PeerManagerMock) AnnounceTransaction(txHash *chainhash.Hash, peers []p2p.PeerI) []p2p.PeerI {
	if mock.AnnounceTransactionFunc == nil {
		panic("PeerManagerMock.AnnounceTransactionFunc: method is nil but PeerManager.AnnounceTransaction was just called")
	}
	callInfo := struct {
		TxHash *chainhash.Hash
		Peers  []p2p.PeerI
	}{
		TxHash: txHash,
		Peers:  peers,
	}
	mock.lockAnnounceTransaction.Lock()
	mock.calls.AnnounceTransaction = append(mock.calls.AnnounceTransaction, callInfo)
	mock.lockAnnounceTransaction.Unlock()
	return mock.AnnounceTransactionFunc(txHash, peers)
}

// AnnounceTransactionCalls gets all the calls that were made to AnnounceTransaction.
// Check the length with:
//
//	len(mockedPeerManager.AnnounceTransactionCalls())
func (mock *PeerManagerMock) AnnounceTransactionCalls() []struct {
	TxHash *chainhash.Hash
	Peers  []p2p.PeerI
} {
	var calls []struct {
		TxHash *chainhash.Hash
		Peers  []p2p.PeerI
	}
	mock.lockAnnounceTransaction.RLock()
	calls = mock.calls.AnnounceTransaction
	mock.lockAnnounceTransaction.RUnlock()
	return calls
}

// GetPeers calls GetPeersFunc.
func (mock *PeerManagerMock) GetPeers() []p2p.PeerI {
	if mock.GetPeersFunc == nil {
		panic("PeerManagerMock.GetPeersFunc: method is nil but PeerManager.GetPeers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetPeers.Lock()
	mock.calls.GetPeers = append(mock.calls.GetPeers, callInfo)
	mock.lockGetPeers.Unlock()
	return mock.GetPeersFunc()
}

// GetPeersCalls gets all the calls that were made to GetPeers.
// Check the length with:
//
//	len(mockedPeerManager.GetPeersCalls())
func (mock *PeerManagerMock) GetPeersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetPeers.RLock()
	calls = mock.calls.GetPeers
	mock.lockGetPeers.RUnlock()
	return calls
}

// RequestBlock calls RequestBlockFunc.
func (mock *PeerManagerMock) RequestBlock(blockHash *chainhash.Hash) p2p.PeerI {
	if mock.RequestBlockFunc == nil {
		panic("PeerManagerMock.RequestBlockFunc: method is nil but PeerManager.RequestBlock was just called")
	}
	callInfo := struct {
		BlockHash *chainhash.Hash
	}{
		BlockHash: blockHash,
	}
	mock.lockRequestBlock.Lock()
	mock.calls.RequestBlock = append(mock.calls.RequestBlock, callInfo)
	mock.lockRequestBlock.Unlock()
	return mock.RequestBlockFunc(blockHash)
}

// RequestBlockCalls gets all the calls that were made to RequestBlock.
// Check the length with:
//
//	len(mockedPeerManager.RequestBlockCalls())
func (mock *PeerManagerMock) RequestBlockCalls() []struct {
	BlockHash *chainhash.Hash
} {
	var calls []struct {
		BlockHash *chainhash.Hash
	}
	mock.lockRequestBlock.RLock()
	calls = mock.calls.RequestBlock
	mock.lockRequestBlock.RUnlock()
	return calls
}

// RequestTransaction calls RequestTransactionFunc.
func (mock *PeerManagerMock) RequestTransaction(txHash *chainhash.Hash) p2p.PeerI {
	if mock.RequestTransactionFunc == nil {
		panic("PeerManagerMock.RequestTransactionFunc: method is nil but PeerManager.RequestTransaction was just called")
	}
	callInfo := struct {
		TxHash *chainhash.Hash
	}{
		TxHash: txHash,
	}
	mock.lockRequestTransaction.Lock()
	mock.calls.RequestTransaction = append(mock.calls.RequestTransaction, callInfo)
	mock.lockRequestTransaction.Unlock()
	return mock.RequestTransactionFunc(txHash)
}

// RequestTransactionCalls gets all the calls that were made to RequestTransaction.
// Check the length with:
//
//	len(mockedPeerManager.RequestTransactionCalls())
func (mock *PeerManagerMock) RequestTransactionCalls() []struct {
	TxHash *chainhash.Hash
} {
	var calls []struct {
		TxHash *chainhash.Hash
	}
	mock.lockRequestTransaction.RLock()
	calls = mock.calls.RequestTransaction
	mock.lockRequestTransaction.RUnlock()
	return calls
}
