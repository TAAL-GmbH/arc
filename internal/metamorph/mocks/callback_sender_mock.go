// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitcoin-sv/arc/internal/metamorph"
	"github.com/bitcoin-sv/arc/internal/metamorph/store"
	"log/slog"
	"sync"
)

// Ensure, that CallbackSenderMock does implement metamorph.CallbackSender.
// If this is not the case, regenerate this file with moq.
var _ metamorph.CallbackSender = &CallbackSenderMock{}

// CallbackSenderMock is a mock implementation of metamorph.CallbackSender.
//
//	func TestSomethingThatUsesCallbackSender(t *testing.T) {
//
//		// make and configure a mocked metamorph.CallbackSender
//		mockedCallbackSender := &CallbackSenderMock{
//			SendCallbackFunc: func(logger *slog.Logger, tx *store.StoreData)  {
//				panic("mock out the SendCallback method")
//			},
//			ShutdownFunc: func(logger *slog.Logger)  {
//				panic("mock out the Shutdown method")
//			},
//		}
//
//		// use mockedCallbackSender in code that requires metamorph.CallbackSender
//		// and then make assertions.
//
//	}
type CallbackSenderMock struct {
	// SendCallbackFunc mocks the SendCallback method.
	SendCallbackFunc func(logger *slog.Logger, tx *store.StoreData)

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(logger *slog.Logger)

	// calls tracks calls to the methods.
	calls struct {
		// SendCallback holds details about calls to the SendCallback method.
		SendCallback []struct {
			// Logger is the logger argument value.
			Logger *slog.Logger
			// Tx is the tx argument value.
			Tx *store.StoreData
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// Logger is the logger argument value.
			Logger *slog.Logger
		}
	}
	lockSendCallback sync.RWMutex
	lockShutdown     sync.RWMutex
}

// SendCallback calls SendCallbackFunc.
func (mock *CallbackSenderMock) SendCallback(logger *slog.Logger, tx *store.StoreData) {
	if mock.SendCallbackFunc == nil {
		panic("CallbackSenderMock.SendCallbackFunc: method is nil but CallbackSender.SendCallback was just called")
	}
	callInfo := struct {
		Logger *slog.Logger
		Tx     *store.StoreData
	}{
		Logger: logger,
		Tx:     tx,
	}
	mock.lockSendCallback.Lock()
	mock.calls.SendCallback = append(mock.calls.SendCallback, callInfo)
	mock.lockSendCallback.Unlock()
	mock.SendCallbackFunc(logger, tx)
}

// SendCallbackCalls gets all the calls that were made to SendCallback.
// Check the length with:
//
//	len(mockedCallbackSender.SendCallbackCalls())
func (mock *CallbackSenderMock) SendCallbackCalls() []struct {
	Logger *slog.Logger
	Tx     *store.StoreData
} {
	var calls []struct {
		Logger *slog.Logger
		Tx     *store.StoreData
	}
	mock.lockSendCallback.RLock()
	calls = mock.calls.SendCallback
	mock.lockSendCallback.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *CallbackSenderMock) Shutdown(logger *slog.Logger) {
	if mock.ShutdownFunc == nil {
		panic("CallbackSenderMock.ShutdownFunc: method is nil but CallbackSender.Shutdown was just called")
	}
	callInfo := struct {
		Logger *slog.Logger
	}{
		Logger: logger,
	}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	mock.ShutdownFunc(logger)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedCallbackSender.ShutdownCalls())
func (mock *CallbackSenderMock) ShutdownCalls() []struct {
	Logger *slog.Logger
} {
	var calls []struct {
		Logger *slog.Logger
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}
