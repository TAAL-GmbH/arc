// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitcoin-sv/arc/internal/metamorph"
	"github.com/libsv/go-p2p/chaincfg/chainhash"
	"github.com/libsv/go-p2p/wire"
	"sync"
)

// Ensure, that PeerIMock does implement metamorph.PeerI.
// If this is not the case, regenerate this file with moq.
var _ metamorph.PeerI = &PeerIMock{}

// PeerIMock is a mock implementation of metamorph.PeerI.
//
//	func TestSomethingThatUsesPeerI(t *testing.T) {
//
//		// make and configure a mocked metamorph.PeerI
//		mockedPeerI := &PeerIMock{
//			AnnounceBlockFunc: func(blockHash *chainhash.Hash)  {
//				panic("mock out the AnnounceBlock method")
//			},
//			AnnounceTransactionFunc: func(txHash *chainhash.Hash)  {
//				panic("mock out the AnnounceTransaction method")
//			},
//			ConnectedFunc: func() bool {
//				panic("mock out the Connected method")
//			},
//			IsHealthyFunc: func() bool {
//				panic("mock out the IsHealthy method")
//			},
//			NetworkFunc: func() wire.BitcoinNet {
//				panic("mock out the Network method")
//			},
//			RequestBlockFunc: func(blockHash *chainhash.Hash)  {
//				panic("mock out the RequestBlock method")
//			},
//			RequestTransactionFunc: func(txHash *chainhash.Hash)  {
//				panic("mock out the RequestTransaction method")
//			},
//			RestartFunc: func()  {
//				panic("mock out the Restart method")
//			},
//			ShutdownFunc: func()  {
//				panic("mock out the Shutdown method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			WriteMsgFunc: func(msg wire.Message) error {
//				panic("mock out the WriteMsg method")
//			},
//		}
//
//		// use mockedPeerI in code that requires metamorph.PeerI
//		// and then make assertions.
//
//	}
type PeerIMock struct {
	// AnnounceBlockFunc mocks the AnnounceBlock method.
	AnnounceBlockFunc func(blockHash *chainhash.Hash)

	// AnnounceTransactionFunc mocks the AnnounceTransaction method.
	AnnounceTransactionFunc func(txHash *chainhash.Hash)

	// ConnectedFunc mocks the Connected method.
	ConnectedFunc func() bool

	// IsHealthyFunc mocks the IsHealthy method.
	IsHealthyFunc func() bool

	// NetworkFunc mocks the Network method.
	NetworkFunc func() wire.BitcoinNet

	// RequestBlockFunc mocks the RequestBlock method.
	RequestBlockFunc func(blockHash *chainhash.Hash)

	// RequestTransactionFunc mocks the RequestTransaction method.
	RequestTransactionFunc func(txHash *chainhash.Hash)

	// RestartFunc mocks the Restart method.
	RestartFunc func()

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func()

	// StringFunc mocks the String method.
	StringFunc func() string

	// WriteMsgFunc mocks the WriteMsg method.
	WriteMsgFunc func(msg wire.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// AnnounceBlock holds details about calls to the AnnounceBlock method.
		AnnounceBlock []struct {
			// BlockHash is the blockHash argument value.
			BlockHash *chainhash.Hash
		}
		// AnnounceTransaction holds details about calls to the AnnounceTransaction method.
		AnnounceTransaction []struct {
			// TxHash is the txHash argument value.
			TxHash *chainhash.Hash
		}
		// Connected holds details about calls to the Connected method.
		Connected []struct {
		}
		// IsHealthy holds details about calls to the IsHealthy method.
		IsHealthy []struct {
		}
		// Network holds details about calls to the Network method.
		Network []struct {
		}
		// RequestBlock holds details about calls to the RequestBlock method.
		RequestBlock []struct {
			// BlockHash is the blockHash argument value.
			BlockHash *chainhash.Hash
		}
		// RequestTransaction holds details about calls to the RequestTransaction method.
		RequestTransaction []struct {
			// TxHash is the txHash argument value.
			TxHash *chainhash.Hash
		}
		// Restart holds details about calls to the Restart method.
		Restart []struct {
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// WriteMsg holds details about calls to the WriteMsg method.
		WriteMsg []struct {
			// Msg is the msg argument value.
			Msg wire.Message
		}
	}
	lockAnnounceBlock       sync.RWMutex
	lockAnnounceTransaction sync.RWMutex
	lockConnected           sync.RWMutex
	lockIsHealthy           sync.RWMutex
	lockNetwork             sync.RWMutex
	lockRequestBlock        sync.RWMutex
	lockRequestTransaction  sync.RWMutex
	lockRestart             sync.RWMutex
	lockShutdown            sync.RWMutex
	lockString              sync.RWMutex
	lockWriteMsg            sync.RWMutex
}

// AnnounceBlock calls AnnounceBlockFunc.
func (mock *PeerIMock) AnnounceBlock(blockHash *chainhash.Hash) {
	if mock.AnnounceBlockFunc == nil {
		panic("PeerIMock.AnnounceBlockFunc: method is nil but PeerI.AnnounceBlock was just called")
	}
	callInfo := struct {
		BlockHash *chainhash.Hash
	}{
		BlockHash: blockHash,
	}
	mock.lockAnnounceBlock.Lock()
	mock.calls.AnnounceBlock = append(mock.calls.AnnounceBlock, callInfo)
	mock.lockAnnounceBlock.Unlock()
	mock.AnnounceBlockFunc(blockHash)
}

// AnnounceBlockCalls gets all the calls that were made to AnnounceBlock.
// Check the length with:
//
//	len(mockedPeerI.AnnounceBlockCalls())
func (mock *PeerIMock) AnnounceBlockCalls() []struct {
	BlockHash *chainhash.Hash
} {
	var calls []struct {
		BlockHash *chainhash.Hash
	}
	mock.lockAnnounceBlock.RLock()
	calls = mock.calls.AnnounceBlock
	mock.lockAnnounceBlock.RUnlock()
	return calls
}

// AnnounceTransaction calls AnnounceTransactionFunc.
func (mock *PeerIMock) AnnounceTransaction(txHash *chainhash.Hash) {
	if mock.AnnounceTransactionFunc == nil {
		panic("PeerIMock.AnnounceTransactionFunc: method is nil but PeerI.AnnounceTransaction was just called")
	}
	callInfo := struct {
		TxHash *chainhash.Hash
	}{
		TxHash: txHash,
	}
	mock.lockAnnounceTransaction.Lock()
	mock.calls.AnnounceTransaction = append(mock.calls.AnnounceTransaction, callInfo)
	mock.lockAnnounceTransaction.Unlock()
	mock.AnnounceTransactionFunc(txHash)
}

// AnnounceTransactionCalls gets all the calls that were made to AnnounceTransaction.
// Check the length with:
//
//	len(mockedPeerI.AnnounceTransactionCalls())
func (mock *PeerIMock) AnnounceTransactionCalls() []struct {
	TxHash *chainhash.Hash
} {
	var calls []struct {
		TxHash *chainhash.Hash
	}
	mock.lockAnnounceTransaction.RLock()
	calls = mock.calls.AnnounceTransaction
	mock.lockAnnounceTransaction.RUnlock()
	return calls
}

// Connected calls ConnectedFunc.
func (mock *PeerIMock) Connected() bool {
	if mock.ConnectedFunc == nil {
		panic("PeerIMock.ConnectedFunc: method is nil but PeerI.Connected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConnected.Lock()
	mock.calls.Connected = append(mock.calls.Connected, callInfo)
	mock.lockConnected.Unlock()
	return mock.ConnectedFunc()
}

// ConnectedCalls gets all the calls that were made to Connected.
// Check the length with:
//
//	len(mockedPeerI.ConnectedCalls())
func (mock *PeerIMock) ConnectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConnected.RLock()
	calls = mock.calls.Connected
	mock.lockConnected.RUnlock()
	return calls
}

// IsHealthy calls IsHealthyFunc.
func (mock *PeerIMock) IsHealthy() bool {
	if mock.IsHealthyFunc == nil {
		panic("PeerIMock.IsHealthyFunc: method is nil but PeerI.IsHealthy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsHealthy.Lock()
	mock.calls.IsHealthy = append(mock.calls.IsHealthy, callInfo)
	mock.lockIsHealthy.Unlock()
	return mock.IsHealthyFunc()
}

// IsHealthyCalls gets all the calls that were made to IsHealthy.
// Check the length with:
//
//	len(mockedPeerI.IsHealthyCalls())
func (mock *PeerIMock) IsHealthyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsHealthy.RLock()
	calls = mock.calls.IsHealthy
	mock.lockIsHealthy.RUnlock()
	return calls
}

// Network calls NetworkFunc.
func (mock *PeerIMock) Network() wire.BitcoinNet {
	if mock.NetworkFunc == nil {
		panic("PeerIMock.NetworkFunc: method is nil but PeerI.Network was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNetwork.Lock()
	mock.calls.Network = append(mock.calls.Network, callInfo)
	mock.lockNetwork.Unlock()
	return mock.NetworkFunc()
}

// NetworkCalls gets all the calls that were made to Network.
// Check the length with:
//
//	len(mockedPeerI.NetworkCalls())
func (mock *PeerIMock) NetworkCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNetwork.RLock()
	calls = mock.calls.Network
	mock.lockNetwork.RUnlock()
	return calls
}

// RequestBlock calls RequestBlockFunc.
func (mock *PeerIMock) RequestBlock(blockHash *chainhash.Hash) {
	if mock.RequestBlockFunc == nil {
		panic("PeerIMock.RequestBlockFunc: method is nil but PeerI.RequestBlock was just called")
	}
	callInfo := struct {
		BlockHash *chainhash.Hash
	}{
		BlockHash: blockHash,
	}
	mock.lockRequestBlock.Lock()
	mock.calls.RequestBlock = append(mock.calls.RequestBlock, callInfo)
	mock.lockRequestBlock.Unlock()
	mock.RequestBlockFunc(blockHash)
}

// RequestBlockCalls gets all the calls that were made to RequestBlock.
// Check the length with:
//
//	len(mockedPeerI.RequestBlockCalls())
func (mock *PeerIMock) RequestBlockCalls() []struct {
	BlockHash *chainhash.Hash
} {
	var calls []struct {
		BlockHash *chainhash.Hash
	}
	mock.lockRequestBlock.RLock()
	calls = mock.calls.RequestBlock
	mock.lockRequestBlock.RUnlock()
	return calls
}

// RequestTransaction calls RequestTransactionFunc.
func (mock *PeerIMock) RequestTransaction(txHash *chainhash.Hash) {
	if mock.RequestTransactionFunc == nil {
		panic("PeerIMock.RequestTransactionFunc: method is nil but PeerI.RequestTransaction was just called")
	}
	callInfo := struct {
		TxHash *chainhash.Hash
	}{
		TxHash: txHash,
	}
	mock.lockRequestTransaction.Lock()
	mock.calls.RequestTransaction = append(mock.calls.RequestTransaction, callInfo)
	mock.lockRequestTransaction.Unlock()
	mock.RequestTransactionFunc(txHash)
}

// RequestTransactionCalls gets all the calls that were made to RequestTransaction.
// Check the length with:
//
//	len(mockedPeerI.RequestTransactionCalls())
func (mock *PeerIMock) RequestTransactionCalls() []struct {
	TxHash *chainhash.Hash
} {
	var calls []struct {
		TxHash *chainhash.Hash
	}
	mock.lockRequestTransaction.RLock()
	calls = mock.calls.RequestTransaction
	mock.lockRequestTransaction.RUnlock()
	return calls
}

// Restart calls RestartFunc.
func (mock *PeerIMock) Restart() {
	if mock.RestartFunc == nil {
		panic("PeerIMock.RestartFunc: method is nil but PeerI.Restart was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRestart.Lock()
	mock.calls.Restart = append(mock.calls.Restart, callInfo)
	mock.lockRestart.Unlock()
	mock.RestartFunc()
}

// RestartCalls gets all the calls that were made to Restart.
// Check the length with:
//
//	len(mockedPeerI.RestartCalls())
func (mock *PeerIMock) RestartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRestart.RLock()
	calls = mock.calls.Restart
	mock.lockRestart.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *PeerIMock) Shutdown() {
	if mock.ShutdownFunc == nil {
		panic("PeerIMock.ShutdownFunc: method is nil but PeerI.Shutdown was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	mock.ShutdownFunc()
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedPeerI.ShutdownCalls())
func (mock *PeerIMock) ShutdownCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *PeerIMock) String() string {
	if mock.StringFunc == nil {
		panic("PeerIMock.StringFunc: method is nil but PeerI.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedPeerI.StringCalls())
func (mock *PeerIMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// WriteMsg calls WriteMsgFunc.
func (mock *PeerIMock) WriteMsg(msg wire.Message) error {
	if mock.WriteMsgFunc == nil {
		panic("PeerIMock.WriteMsgFunc: method is nil but PeerI.WriteMsg was just called")
	}
	callInfo := struct {
		Msg wire.Message
	}{
		Msg: msg,
	}
	mock.lockWriteMsg.Lock()
	mock.calls.WriteMsg = append(mock.calls.WriteMsg, callInfo)
	mock.lockWriteMsg.Unlock()
	return mock.WriteMsgFunc(msg)
}

// WriteMsgCalls gets all the calls that were made to WriteMsg.
// Check the length with:
//
//	len(mockedPeerI.WriteMsgCalls())
func (mock *PeerIMock) WriteMsgCalls() []struct {
	Msg wire.Message
} {
	var calls []struct {
		Msg wire.Message
	}
	mock.lockWriteMsg.RLock()
	calls = mock.calls.WriteMsg
	mock.lockWriteMsg.RUnlock()
	return calls
}
