// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitcoin-sv/arc/internal/metamorph"
	"github.com/libsv/go-p2p"
	"sync"
)

// Ensure, that ProcessorIMock does implement metamorph.ProcessorI.
// If this is not the case, regenerate this file with moq.
var _ metamorph.ProcessorI = &ProcessorIMock{}

// ProcessorIMock is a mock implementation of metamorph.ProcessorI.
//
//	func TestSomethingThatUsesProcessorI(t *testing.T) {
//
//		// make and configure a mocked metamorph.ProcessorI
//		mockedProcessorI := &ProcessorIMock{
//			GetCallbackerStatsFunc: func() metamorph.CallbackerStats {
//				panic("mock out the GetCallbackerStats method")
//			},
//			GetPeersFunc: func() []p2p.PeerI {
//				panic("mock out the GetPeers method")
//			},
//			GetStatsFunc: func(debugItems bool) *metamorph.ProcessorStats {
//				panic("mock out the GetStats method")
//			},
//			HealthFunc: func() error {
//				panic("mock out the Health method")
//			},
//			ProcessTransactionFunc: func(ctx context.Context, req *metamorph.ProcessorRequest)  {
//				panic("mock out the ProcessTransaction method")
//			},
//			ShutdownFunc: func()  {
//				panic("mock out the Shutdown method")
//			},
//		}
//
//		// use mockedProcessorI in code that requires metamorph.ProcessorI
//		// and then make assertions.
//
//	}
type ProcessorIMock struct {
	// GetCallbackerStatsFunc mocks the GetCallbackerStats method.
	GetCallbackerStatsFunc func() metamorph.CallbackerStats

	// GetPeersFunc mocks the GetPeers method.
	GetPeersFunc func() []p2p.PeerI

	// GetStatsFunc mocks the GetStats method.
	GetStatsFunc func(debugItems bool) *metamorph.ProcessorStats

	// HealthFunc mocks the Health method.
	HealthFunc func() error

	// ProcessTransactionFunc mocks the ProcessTransaction method.
	ProcessTransactionFunc func(ctx context.Context, req *metamorph.ProcessorRequest)

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// GetCallbackerStats holds details about calls to the GetCallbackerStats method.
		GetCallbackerStats []struct {
		}
		// GetPeers holds details about calls to the GetPeers method.
		GetPeers []struct {
		}
		// GetStats holds details about calls to the GetStats method.
		GetStats []struct {
			// DebugItems is the debugItems argument value.
			DebugItems bool
		}
		// Health holds details about calls to the Health method.
		Health []struct {
		}
		// ProcessTransaction holds details about calls to the ProcessTransaction method.
		ProcessTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *metamorph.ProcessorRequest
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
		}
	}
	lockGetCallbackerStats sync.RWMutex
	lockGetPeers           sync.RWMutex
	lockGetStats           sync.RWMutex
	lockHealth             sync.RWMutex
	lockProcessTransaction sync.RWMutex
	lockShutdown           sync.RWMutex
}

// GetCallbackerStats calls GetCallbackerStatsFunc.
func (mock *ProcessorIMock) GetCallbackerStats() metamorph.CallbackerStats {
	if mock.GetCallbackerStatsFunc == nil {
		panic("ProcessorIMock.GetCallbackerStatsFunc: method is nil but ProcessorI.GetCallbackerStats was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetCallbackerStats.Lock()
	mock.calls.GetCallbackerStats = append(mock.calls.GetCallbackerStats, callInfo)
	mock.lockGetCallbackerStats.Unlock()
	return mock.GetCallbackerStatsFunc()
}

// GetCallbackerStatsCalls gets all the calls that were made to GetCallbackerStats.
// Check the length with:
//
//	len(mockedProcessorI.GetCallbackerStatsCalls())
func (mock *ProcessorIMock) GetCallbackerStatsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetCallbackerStats.RLock()
	calls = mock.calls.GetCallbackerStats
	mock.lockGetCallbackerStats.RUnlock()
	return calls
}

// GetPeers calls GetPeersFunc.
func (mock *ProcessorIMock) GetPeers() []p2p.PeerI {
	if mock.GetPeersFunc == nil {
		panic("ProcessorIMock.GetPeersFunc: method is nil but ProcessorI.GetPeers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetPeers.Lock()
	mock.calls.GetPeers = append(mock.calls.GetPeers, callInfo)
	mock.lockGetPeers.Unlock()
	return mock.GetPeersFunc()
}

// GetPeersCalls gets all the calls that were made to GetPeers.
// Check the length with:
//
//	len(mockedProcessorI.GetPeersCalls())
func (mock *ProcessorIMock) GetPeersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetPeers.RLock()
	calls = mock.calls.GetPeers
	mock.lockGetPeers.RUnlock()
	return calls
}

// GetStats calls GetStatsFunc.
func (mock *ProcessorIMock) GetStats(debugItems bool) *metamorph.ProcessorStats {
	if mock.GetStatsFunc == nil {
		panic("ProcessorIMock.GetStatsFunc: method is nil but ProcessorI.GetStats was just called")
	}
	callInfo := struct {
		DebugItems bool
	}{
		DebugItems: debugItems,
	}
	mock.lockGetStats.Lock()
	mock.calls.GetStats = append(mock.calls.GetStats, callInfo)
	mock.lockGetStats.Unlock()
	return mock.GetStatsFunc(debugItems)
}

// GetStatsCalls gets all the calls that were made to GetStats.
// Check the length with:
//
//	len(mockedProcessorI.GetStatsCalls())
func (mock *ProcessorIMock) GetStatsCalls() []struct {
	DebugItems bool
} {
	var calls []struct {
		DebugItems bool
	}
	mock.lockGetStats.RLock()
	calls = mock.calls.GetStats
	mock.lockGetStats.RUnlock()
	return calls
}

// Health calls HealthFunc.
func (mock *ProcessorIMock) Health() error {
	if mock.HealthFunc == nil {
		panic("ProcessorIMock.HealthFunc: method is nil but ProcessorI.Health was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHealth.Lock()
	mock.calls.Health = append(mock.calls.Health, callInfo)
	mock.lockHealth.Unlock()
	return mock.HealthFunc()
}

// HealthCalls gets all the calls that were made to Health.
// Check the length with:
//
//	len(mockedProcessorI.HealthCalls())
func (mock *ProcessorIMock) HealthCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHealth.RLock()
	calls = mock.calls.Health
	mock.lockHealth.RUnlock()
	return calls
}

// ProcessTransaction calls ProcessTransactionFunc.
func (mock *ProcessorIMock) ProcessTransaction(ctx context.Context, req *metamorph.ProcessorRequest) {
	if mock.ProcessTransactionFunc == nil {
		panic("ProcessorIMock.ProcessTransactionFunc: method is nil but ProcessorI.ProcessTransaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *metamorph.ProcessorRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockProcessTransaction.Lock()
	mock.calls.ProcessTransaction = append(mock.calls.ProcessTransaction, callInfo)
	mock.lockProcessTransaction.Unlock()
	mock.ProcessTransactionFunc(ctx, req)
}

// ProcessTransactionCalls gets all the calls that were made to ProcessTransaction.
// Check the length with:
//
//	len(mockedProcessorI.ProcessTransactionCalls())
func (mock *ProcessorIMock) ProcessTransactionCalls() []struct {
	Ctx context.Context
	Req *metamorph.ProcessorRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *metamorph.ProcessorRequest
	}
	mock.lockProcessTransaction.RLock()
	calls = mock.calls.ProcessTransaction
	mock.lockProcessTransaction.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *ProcessorIMock) Shutdown() {
	if mock.ShutdownFunc == nil {
		panic("ProcessorIMock.ShutdownFunc: method is nil but ProcessorI.Shutdown was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	mock.ShutdownFunc()
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedProcessorI.ShutdownCalls())
func (mock *ProcessorIMock) ShutdownCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}
