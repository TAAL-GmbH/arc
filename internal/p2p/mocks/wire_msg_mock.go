// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/libsv/go-p2p/wire"
	"io"
	"sync"
)

// Ensure, that MessageMock does implement wire.Message.
// If this is not the case, regenerate this file with moq.
var _ wire.Message = &MessageMock{}

// MessageMock is a mock implementation of wire.Message.
//
//	func TestSomethingThatUsesMessage(t *testing.T) {
//
//		// make and configure a mocked wire.Message
//		mockedMessage := &MessageMock{
//			BsvEncodeFunc: func(writer io.Writer, v uint32, messageEncoding wire.MessageEncoding) error {
//				panic("mock out the BsvEncode method")
//			},
//			BsvdecodeFunc: func(reader io.Reader, v uint32, messageEncoding wire.MessageEncoding) error {
//				panic("mock out the Bsvdecode method")
//			},
//			CommandFunc: func() string {
//				panic("mock out the Command method")
//			},
//			MaxPayloadLengthFunc: func(v uint32) uint64 {
//				panic("mock out the MaxPayloadLength method")
//			},
//		}
//
//		// use mockedMessage in code that requires wire.Message
//		// and then make assertions.
//
//	}
type MessageMock struct {
	// BsvEncodeFunc mocks the BsvEncode method.
	BsvEncodeFunc func(writer io.Writer, v uint32, messageEncoding wire.MessageEncoding) error

	// BsvdecodeFunc mocks the Bsvdecode method.
	BsvdecodeFunc func(reader io.Reader, v uint32, messageEncoding wire.MessageEncoding) error

	// CommandFunc mocks the Command method.
	CommandFunc func() string

	// MaxPayloadLengthFunc mocks the MaxPayloadLength method.
	MaxPayloadLengthFunc func(v uint32) uint64

	// calls tracks calls to the methods.
	calls struct {
		// BsvEncode holds details about calls to the BsvEncode method.
		BsvEncode []struct {
			// Writer is the writer argument value.
			Writer io.Writer
			// V is the v argument value.
			V uint32
			// MessageEncoding is the messageEncoding argument value.
			MessageEncoding wire.MessageEncoding
		}
		// Bsvdecode holds details about calls to the Bsvdecode method.
		Bsvdecode []struct {
			// Reader is the reader argument value.
			Reader io.Reader
			// V is the v argument value.
			V uint32
			// MessageEncoding is the messageEncoding argument value.
			MessageEncoding wire.MessageEncoding
		}
		// Command holds details about calls to the Command method.
		Command []struct {
		}
		// MaxPayloadLength holds details about calls to the MaxPayloadLength method.
		MaxPayloadLength []struct {
			// V is the v argument value.
			V uint32
		}
	}
	lockBsvEncode        sync.RWMutex
	lockBsvdecode        sync.RWMutex
	lockCommand          sync.RWMutex
	lockMaxPayloadLength sync.RWMutex
}

// BsvEncode calls BsvEncodeFunc.
func (mock *MessageMock) BsvEncode(writer io.Writer, v uint32, messageEncoding wire.MessageEncoding) error {
	if mock.BsvEncodeFunc == nil {
		panic("MessageMock.BsvEncodeFunc: method is nil but Message.BsvEncode was just called")
	}
	callInfo := struct {
		Writer          io.Writer
		V               uint32
		MessageEncoding wire.MessageEncoding
	}{
		Writer:          writer,
		V:               v,
		MessageEncoding: messageEncoding,
	}
	mock.lockBsvEncode.Lock()
	mock.calls.BsvEncode = append(mock.calls.BsvEncode, callInfo)
	mock.lockBsvEncode.Unlock()
	return mock.BsvEncodeFunc(writer, v, messageEncoding)
}

// BsvEncodeCalls gets all the calls that were made to BsvEncode.
// Check the length with:
//
//	len(mockedMessage.BsvEncodeCalls())
func (mock *MessageMock) BsvEncodeCalls() []struct {
	Writer          io.Writer
	V               uint32
	MessageEncoding wire.MessageEncoding
} {
	var calls []struct {
		Writer          io.Writer
		V               uint32
		MessageEncoding wire.MessageEncoding
	}
	mock.lockBsvEncode.RLock()
	calls = mock.calls.BsvEncode
	mock.lockBsvEncode.RUnlock()
	return calls
}

// Bsvdecode calls BsvdecodeFunc.
func (mock *MessageMock) Bsvdecode(reader io.Reader, v uint32, messageEncoding wire.MessageEncoding) error {
	if mock.BsvdecodeFunc == nil {
		panic("MessageMock.BsvdecodeFunc: method is nil but Message.Bsvdecode was just called")
	}
	callInfo := struct {
		Reader          io.Reader
		V               uint32
		MessageEncoding wire.MessageEncoding
	}{
		Reader:          reader,
		V:               v,
		MessageEncoding: messageEncoding,
	}
	mock.lockBsvdecode.Lock()
	mock.calls.Bsvdecode = append(mock.calls.Bsvdecode, callInfo)
	mock.lockBsvdecode.Unlock()
	return mock.BsvdecodeFunc(reader, v, messageEncoding)
}

// BsvdecodeCalls gets all the calls that were made to Bsvdecode.
// Check the length with:
//
//	len(mockedMessage.BsvdecodeCalls())
func (mock *MessageMock) BsvdecodeCalls() []struct {
	Reader          io.Reader
	V               uint32
	MessageEncoding wire.MessageEncoding
} {
	var calls []struct {
		Reader          io.Reader
		V               uint32
		MessageEncoding wire.MessageEncoding
	}
	mock.lockBsvdecode.RLock()
	calls = mock.calls.Bsvdecode
	mock.lockBsvdecode.RUnlock()
	return calls
}

// Command calls CommandFunc.
func (mock *MessageMock) Command() string {
	if mock.CommandFunc == nil {
		panic("MessageMock.CommandFunc: method is nil but Message.Command was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommand.Lock()
	mock.calls.Command = append(mock.calls.Command, callInfo)
	mock.lockCommand.Unlock()
	return mock.CommandFunc()
}

// CommandCalls gets all the calls that were made to Command.
// Check the length with:
//
//	len(mockedMessage.CommandCalls())
func (mock *MessageMock) CommandCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommand.RLock()
	calls = mock.calls.Command
	mock.lockCommand.RUnlock()
	return calls
}

// MaxPayloadLength calls MaxPayloadLengthFunc.
func (mock *MessageMock) MaxPayloadLength(v uint32) uint64 {
	if mock.MaxPayloadLengthFunc == nil {
		panic("MessageMock.MaxPayloadLengthFunc: method is nil but Message.MaxPayloadLength was just called")
	}
	callInfo := struct {
		V uint32
	}{
		V: v,
	}
	mock.lockMaxPayloadLength.Lock()
	mock.calls.MaxPayloadLength = append(mock.calls.MaxPayloadLength, callInfo)
	mock.lockMaxPayloadLength.Unlock()
	return mock.MaxPayloadLengthFunc(v)
}

// MaxPayloadLengthCalls gets all the calls that were made to MaxPayloadLength.
// Check the length with:
//
//	len(mockedMessage.MaxPayloadLengthCalls())
func (mock *MessageMock) MaxPayloadLengthCalls() []struct {
	V uint32
} {
	var calls []struct {
		V uint32
	}
	mock.lockMaxPayloadLength.RLock()
	calls = mock.calls.MaxPayloadLength
	mock.lockMaxPayloadLength.RUnlock()
	return calls
}
