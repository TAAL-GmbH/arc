// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"container/list"
	"github.com/bitcoin-sv/arc/internal/broadcaster"
	"github.com/libsv/go-bt/v2"
	"github.com/libsv/go-bt/v2/bscript"
	"sync"
)

// Ensure, that UtxoClientMock does implement broadcaster.UtxoClient.
// If this is not the case, regenerate this file with moq.
var _ broadcaster.UtxoClient = &UtxoClientMock{}

// UtxoClientMock is a mock implementation of broadcaster.UtxoClient.
//
//	func TestSomethingThatUsesUtxoClient(t *testing.T) {
//
//		// make and configure a mocked broadcaster.UtxoClient
//		mockedUtxoClient := &UtxoClientMock{
//			GetBalanceFunc: func(mainnet bool, address string) (int64, error) {
//				panic("mock out the GetBalance method")
//			},
//			GetUTXOsFunc: func(mainnet bool, lockingScript *bscript.Script, address string) ([]*bt.UTXO, error) {
//				panic("mock out the GetUTXOs method")
//			},
//			GetUTXOsListFunc: func(mainnet bool, lockingScript *bscript.Script, address string) (*list.List, error) {
//				panic("mock out the GetUTXOsList method")
//			},
//			TopUpFunc: func(mainnet bool, address string) error {
//				panic("mock out the TopUp method")
//			},
//		}
//
//		// use mockedUtxoClient in code that requires broadcaster.UtxoClient
//		// and then make assertions.
//
//	}
type UtxoClientMock struct {
	// GetBalanceFunc mocks the GetBalance method.
	GetBalanceFunc func(mainnet bool, address string) (int64, error)

	// GetUTXOsFunc mocks the GetUTXOs method.
	GetUTXOsFunc func(mainnet bool, lockingScript *bscript.Script, address string) ([]*bt.UTXO, error)

	// GetUTXOsListFunc mocks the GetUTXOsList method.
	GetUTXOsListFunc func(mainnet bool, lockingScript *bscript.Script, address string) (*list.List, error)

	// TopUpFunc mocks the TopUp method.
	TopUpFunc func(mainnet bool, address string) error

	// calls tracks calls to the methods.
	calls struct {
		// GetBalance holds details about calls to the GetBalance method.
		GetBalance []struct {
			// Mainnet is the mainnet argument value.
			Mainnet bool
			// Address is the address argument value.
			Address string
		}
		// GetUTXOs holds details about calls to the GetUTXOs method.
		GetUTXOs []struct {
			// Mainnet is the mainnet argument value.
			Mainnet bool
			// LockingScript is the lockingScript argument value.
			LockingScript *bscript.Script
			// Address is the address argument value.
			Address string
		}
		// GetUTXOsList holds details about calls to the GetUTXOsList method.
		GetUTXOsList []struct {
			// Mainnet is the mainnet argument value.
			Mainnet bool
			// LockingScript is the lockingScript argument value.
			LockingScript *bscript.Script
			// Address is the address argument value.
			Address string
		}
		// TopUp holds details about calls to the TopUp method.
		TopUp []struct {
			// Mainnet is the mainnet argument value.
			Mainnet bool
			// Address is the address argument value.
			Address string
		}
	}
	lockGetBalance   sync.RWMutex
	lockGetUTXOs     sync.RWMutex
	lockGetUTXOsList sync.RWMutex
	lockTopUp        sync.RWMutex
}

// GetBalance calls GetBalanceFunc.
func (mock *UtxoClientMock) GetBalance(mainnet bool, address string) (int64, error) {
	if mock.GetBalanceFunc == nil {
		panic("UtxoClientMock.GetBalanceFunc: method is nil but UtxoClient.GetBalance was just called")
	}
	callInfo := struct {
		Mainnet bool
		Address string
	}{
		Mainnet: mainnet,
		Address: address,
	}
	mock.lockGetBalance.Lock()
	mock.calls.GetBalance = append(mock.calls.GetBalance, callInfo)
	mock.lockGetBalance.Unlock()
	return mock.GetBalanceFunc(mainnet, address)
}

// GetBalanceCalls gets all the calls that were made to GetBalance.
// Check the length with:
//
//	len(mockedUtxoClient.GetBalanceCalls())
func (mock *UtxoClientMock) GetBalanceCalls() []struct {
	Mainnet bool
	Address string
} {
	var calls []struct {
		Mainnet bool
		Address string
	}
	mock.lockGetBalance.RLock()
	calls = mock.calls.GetBalance
	mock.lockGetBalance.RUnlock()
	return calls
}

// GetUTXOs calls GetUTXOsFunc.
func (mock *UtxoClientMock) GetUTXOs(mainnet bool, lockingScript *bscript.Script, address string) ([]*bt.UTXO, error) {
	if mock.GetUTXOsFunc == nil {
		panic("UtxoClientMock.GetUTXOsFunc: method is nil but UtxoClient.GetUTXOs was just called")
	}
	callInfo := struct {
		Mainnet       bool
		LockingScript *bscript.Script
		Address       string
	}{
		Mainnet:       mainnet,
		LockingScript: lockingScript,
		Address:       address,
	}
	mock.lockGetUTXOs.Lock()
	mock.calls.GetUTXOs = append(mock.calls.GetUTXOs, callInfo)
	mock.lockGetUTXOs.Unlock()
	return mock.GetUTXOsFunc(mainnet, lockingScript, address)
}

// GetUTXOsCalls gets all the calls that were made to GetUTXOs.
// Check the length with:
//
//	len(mockedUtxoClient.GetUTXOsCalls())
func (mock *UtxoClientMock) GetUTXOsCalls() []struct {
	Mainnet       bool
	LockingScript *bscript.Script
	Address       string
} {
	var calls []struct {
		Mainnet       bool
		LockingScript *bscript.Script
		Address       string
	}
	mock.lockGetUTXOs.RLock()
	calls = mock.calls.GetUTXOs
	mock.lockGetUTXOs.RUnlock()
	return calls
}

// GetUTXOsList calls GetUTXOsListFunc.
func (mock *UtxoClientMock) GetUTXOsList(mainnet bool, lockingScript *bscript.Script, address string) (*list.List, error) {
	if mock.GetUTXOsListFunc == nil {
		panic("UtxoClientMock.GetUTXOsListFunc: method is nil but UtxoClient.GetUTXOsList was just called")
	}
	callInfo := struct {
		Mainnet       bool
		LockingScript *bscript.Script
		Address       string
	}{
		Mainnet:       mainnet,
		LockingScript: lockingScript,
		Address:       address,
	}
	mock.lockGetUTXOsList.Lock()
	mock.calls.GetUTXOsList = append(mock.calls.GetUTXOsList, callInfo)
	mock.lockGetUTXOsList.Unlock()
	return mock.GetUTXOsListFunc(mainnet, lockingScript, address)
}

// GetUTXOsListCalls gets all the calls that were made to GetUTXOsList.
// Check the length with:
//
//	len(mockedUtxoClient.GetUTXOsListCalls())
func (mock *UtxoClientMock) GetUTXOsListCalls() []struct {
	Mainnet       bool
	LockingScript *bscript.Script
	Address       string
} {
	var calls []struct {
		Mainnet       bool
		LockingScript *bscript.Script
		Address       string
	}
	mock.lockGetUTXOsList.RLock()
	calls = mock.calls.GetUTXOsList
	mock.lockGetUTXOsList.RUnlock()
	return calls
}

// TopUp calls TopUpFunc.
func (mock *UtxoClientMock) TopUp(mainnet bool, address string) error {
	if mock.TopUpFunc == nil {
		panic("UtxoClientMock.TopUpFunc: method is nil but UtxoClient.TopUp was just called")
	}
	callInfo := struct {
		Mainnet bool
		Address string
	}{
		Mainnet: mainnet,
		Address: address,
	}
	mock.lockTopUp.Lock()
	mock.calls.TopUp = append(mock.calls.TopUp, callInfo)
	mock.lockTopUp.Unlock()
	return mock.TopUpFunc(mainnet, address)
}

// TopUpCalls gets all the calls that were made to TopUp.
// Check the length with:
//
//	len(mockedUtxoClient.TopUpCalls())
func (mock *UtxoClientMock) TopUpCalls() []struct {
	Mainnet bool
	Address string
} {
	var calls []struct {
		Mainnet bool
		Address string
	}
	mock.lockTopUp.RLock()
	calls = mock.calls.TopUp
	mock.lockTopUp.RUnlock()
	return calls
}
