// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitcoin-sv/arc/internal/blocktx/blocktx_api"
	"github.com/bitcoin-sv/arc/internal/blocktx/store"
	"github.com/libsv/go-p2p/chaincfg/chainhash"
	"sync"
)

// Ensure, that UnitOfWorkMock does implement store.UnitOfWork.
// If this is not the case, regenerate this file with moq.
var _ store.UnitOfWork = &UnitOfWorkMock{}

// UnitOfWorkMock is a mock implementation of store.UnitOfWork.
//
//	func TestSomethingThatUsesUnitOfWork(t *testing.T) {
//
//		// make and configure a mocked store.UnitOfWork
//		mockedUnitOfWork := &UnitOfWorkMock{
//			ClearBlocktxTableFunc: func(ctx context.Context, retentionDays int32, table string) (*blocktx_api.RowsAffectedResponse, error) {
//				panic("mock out the ClearBlocktxTable method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CommitFunc: func() error {
//				panic("mock out the Commit method")
//			},
//			DelBlockProcessingFunc: func(ctx context.Context, hash *chainhash.Hash, processedBy string) (int64, error) {
//				panic("mock out the DelBlockProcessing method")
//			},
//			GetBlockFunc: func(ctx context.Context, hash *chainhash.Hash) (*blocktx_api.Block, error) {
//				panic("mock out the GetBlock method")
//			},
//			GetBlockByHeightFunc: func(ctx context.Context, height uint64) (*blocktx_api.Block, error) {
//				panic("mock out the GetBlockByHeight method")
//			},
//			GetBlockGapsFunc: func(ctx context.Context, heightRange int) ([]*store.BlockGap, error) {
//				panic("mock out the GetBlockGaps method")
//			},
//			GetBlockHashesProcessingInProgressFunc: func(ctx context.Context, processedBy string) ([]*chainhash.Hash, error) {
//				panic("mock out the GetBlockHashesProcessingInProgress method")
//			},
//			GetChainTipFunc: func(ctx context.Context) (*blocktx_api.Block, error) {
//				panic("mock out the GetChainTip method")
//			},
//			GetLongestChainFromHeightFunc: func(ctx context.Context, height uint64) ([]*blocktx_api.Block, error) {
//				panic("mock out the GetLongestChainFromHeight method")
//			},
//			GetMinedTransactionsFunc: func(ctx context.Context, hashes [][]byte, onlyLongestChain bool) ([]store.TransactionBlock, error) {
//				panic("mock out the GetMinedTransactions method")
//			},
//			GetOrphanedChainUpFromHashFunc: func(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error) {
//				panic("mock out the GetOrphanedChainUpFromHash method")
//			},
//			GetRegisteredTxsByBlockHashesFunc: func(ctx context.Context, blockHashes [][]byte) ([]store.TransactionBlock, error) {
//				panic("mock out the GetRegisteredTxsByBlockHashes method")
//			},
//			GetStaleChainBackFromHashFunc: func(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error) {
//				panic("mock out the GetStaleChainBackFromHash method")
//			},
//			MarkBlockAsDoneFunc: func(ctx context.Context, hash *chainhash.Hash, size uint64, txCount uint64) error {
//				panic("mock out the MarkBlockAsDone method")
//			},
//			PingFunc: func(ctx context.Context) error {
//				panic("mock out the Ping method")
//			},
//			RegisterTransactionsFunc: func(ctx context.Context, txHashes [][]byte) ([]*chainhash.Hash, error) {
//				panic("mock out the RegisterTransactions method")
//			},
//			RollbackFunc: func() error {
//				panic("mock out the Rollback method")
//			},
//			SetBlockProcessingFunc: func(ctx context.Context, hash *chainhash.Hash, processedBy string) (string, error) {
//				panic("mock out the SetBlockProcessing method")
//			},
//			StartUnitOfWorkFunc: func(ctx context.Context) (store.UnitOfWork, error) {
//				panic("mock out the StartUnitOfWork method")
//			},
//			TraceToNonOrphanChainFunc: func(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error) {
//				panic("mock out the TraceToNonOrphanChain method")
//			},
//			UpdateBlocksStatusesFunc: func(ctx context.Context, blockStatusUpdates []store.BlockStatusUpdate) error {
//				panic("mock out the UpdateBlocksStatuses method")
//			},
//			UpsertBlockFunc: func(ctx context.Context, block *blocktx_api.Block) (uint64, error) {
//				panic("mock out the UpsertBlock method")
//			},
//			UpsertBlockTransactionsFunc: func(ctx context.Context, blockID uint64, txsWithMerklePaths []store.TxWithMerklePath) error {
//				panic("mock out the UpsertBlockTransactions method")
//			},
//			VerifyMerkleRootsFunc: func(ctx context.Context, merkleRoots []*blocktx_api.MerkleRootVerificationRequest, maxAllowedBlockHeightMismatch int) (*blocktx_api.MerkleRootVerificationResponse, error) {
//				panic("mock out the VerifyMerkleRoots method")
//			},
//			WriteLockBlocksTableFunc: func(ctx context.Context) error {
//				panic("mock out the WriteLockBlocksTable method")
//			},
//		}
//
//		// use mockedUnitOfWork in code that requires store.UnitOfWork
//		// and then make assertions.
//
//	}
type UnitOfWorkMock struct {
	// ClearBlocktxTableFunc mocks the ClearBlocktxTable method.
	ClearBlocktxTableFunc func(ctx context.Context, retentionDays int32, table string) (*blocktx_api.RowsAffectedResponse, error)

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CommitFunc mocks the Commit method.
	CommitFunc func() error

	// DelBlockProcessingFunc mocks the DelBlockProcessing method.
	DelBlockProcessingFunc func(ctx context.Context, hash *chainhash.Hash, processedBy string) (int64, error)

	// GetBlockFunc mocks the GetBlock method.
	GetBlockFunc func(ctx context.Context, hash *chainhash.Hash) (*blocktx_api.Block, error)

	// GetBlockByHeightFunc mocks the GetBlockByHeight method.
	GetBlockByHeightFunc func(ctx context.Context, height uint64) (*blocktx_api.Block, error)

	// GetBlockGapsFunc mocks the GetBlockGaps method.
	GetBlockGapsFunc func(ctx context.Context, heightRange int) ([]*store.BlockGap, error)

	// GetBlockHashesProcessingInProgressFunc mocks the GetBlockHashesProcessingInProgress method.
	GetBlockHashesProcessingInProgressFunc func(ctx context.Context, processedBy string) ([]*chainhash.Hash, error)

	// GetChainTipFunc mocks the GetChainTip method.
	GetChainTipFunc func(ctx context.Context) (*blocktx_api.Block, error)

	// GetLongestChainFromHeightFunc mocks the GetLongestChainFromHeight method.
	GetLongestChainFromHeightFunc func(ctx context.Context, height uint64) ([]*blocktx_api.Block, error)

	// GetMinedTransactionsFunc mocks the GetMinedTransactions method.
	GetMinedTransactionsFunc func(ctx context.Context, hashes [][]byte, onlyLongestChain bool) ([]store.TransactionBlock, error)

	// GetOrphanedChainUpFromHashFunc mocks the GetOrphanedChainUpFromHash method.
	GetOrphanedChainUpFromHashFunc func(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error)

	// GetRegisteredTxsByBlockHashesFunc mocks the GetRegisteredTxsByBlockHashes method.
	GetRegisteredTxsByBlockHashesFunc func(ctx context.Context, blockHashes [][]byte) ([]store.TransactionBlock, error)

	// GetStaleChainBackFromHashFunc mocks the GetStaleChainBackFromHash method.
	GetStaleChainBackFromHashFunc func(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error)

	// MarkBlockAsDoneFunc mocks the MarkBlockAsDone method.
	MarkBlockAsDoneFunc func(ctx context.Context, hash *chainhash.Hash, size uint64, txCount uint64) error

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) error

	// RegisterTransactionsFunc mocks the RegisterTransactions method.
	RegisterTransactionsFunc func(ctx context.Context, txHashes [][]byte) ([]*chainhash.Hash, error)

	// RollbackFunc mocks the Rollback method.
	RollbackFunc func() error

	// SetBlockProcessingFunc mocks the SetBlockProcessing method.
	SetBlockProcessingFunc func(ctx context.Context, hash *chainhash.Hash, processedBy string) (string, error)

	// StartUnitOfWorkFunc mocks the StartUnitOfWork method.
	StartUnitOfWorkFunc func(ctx context.Context) (store.UnitOfWork, error)

	// TraceToNonOrphanChainFunc mocks the TraceToNonOrphanChain method.
	TraceToNonOrphanChainFunc func(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error)

	// UpdateBlocksStatusesFunc mocks the UpdateBlocksStatuses method.
	UpdateBlocksStatusesFunc func(ctx context.Context, blockStatusUpdates []store.BlockStatusUpdate) error

	// UpsertBlockFunc mocks the UpsertBlock method.
	UpsertBlockFunc func(ctx context.Context, block *blocktx_api.Block) (uint64, error)

	// UpsertBlockTransactionsFunc mocks the UpsertBlockTransactions method.
	UpsertBlockTransactionsFunc func(ctx context.Context, blockID uint64, txsWithMerklePaths []store.TxWithMerklePath) error

	// VerifyMerkleRootsFunc mocks the VerifyMerkleRoots method.
	VerifyMerkleRootsFunc func(ctx context.Context, merkleRoots []*blocktx_api.MerkleRootVerificationRequest, maxAllowedBlockHeightMismatch int) (*blocktx_api.MerkleRootVerificationResponse, error)

	// WriteLockBlocksTableFunc mocks the WriteLockBlocksTable method.
	WriteLockBlocksTableFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// ClearBlocktxTable holds details about calls to the ClearBlocktxTable method.
		ClearBlocktxTable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RetentionDays is the retentionDays argument value.
			RetentionDays int32
			// Table is the table argument value.
			Table string
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
		}
		// DelBlockProcessing holds details about calls to the DelBlockProcessing method.
		DelBlockProcessing []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash *chainhash.Hash
			// ProcessedBy is the processedBy argument value.
			ProcessedBy string
		}
		// GetBlock holds details about calls to the GetBlock method.
		GetBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash *chainhash.Hash
		}
		// GetBlockByHeight holds details about calls to the GetBlockByHeight method.
		GetBlockByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height uint64
		}
		// GetBlockGaps holds details about calls to the GetBlockGaps method.
		GetBlockGaps []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// HeightRange is the heightRange argument value.
			HeightRange int
		}
		// GetBlockHashesProcessingInProgress holds details about calls to the GetBlockHashesProcessingInProgress method.
		GetBlockHashesProcessingInProgress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProcessedBy is the processedBy argument value.
			ProcessedBy string
		}
		// GetChainTip holds details about calls to the GetChainTip method.
		GetChainTip []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetLongestChainFromHeight holds details about calls to the GetLongestChainFromHeight method.
		GetLongestChainFromHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height uint64
		}
		// GetMinedTransactions holds details about calls to the GetMinedTransactions method.
		GetMinedTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hashes is the hashes argument value.
			Hashes [][]byte
			// OnlyLongestChain is the onlyLongestChain argument value.
			OnlyLongestChain bool
		}
		// GetOrphanedChainUpFromHash holds details about calls to the GetOrphanedChainUpFromHash method.
		GetOrphanedChainUpFromHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash []byte
		}
		// GetRegisteredTxsByBlockHashes holds details about calls to the GetRegisteredTxsByBlockHashes method.
		GetRegisteredTxsByBlockHashes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHashes is the blockHashes argument value.
			BlockHashes [][]byte
		}
		// GetStaleChainBackFromHash holds details about calls to the GetStaleChainBackFromHash method.
		GetStaleChainBackFromHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash []byte
		}
		// MarkBlockAsDone holds details about calls to the MarkBlockAsDone method.
		MarkBlockAsDone []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash *chainhash.Hash
			// Size is the size argument value.
			Size uint64
			// TxCount is the txCount argument value.
			TxCount uint64
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RegisterTransactions holds details about calls to the RegisterTransactions method.
		RegisterTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxHashes is the txHashes argument value.
			TxHashes [][]byte
		}
		// Rollback holds details about calls to the Rollback method.
		Rollback []struct {
		}
		// SetBlockProcessing holds details about calls to the SetBlockProcessing method.
		SetBlockProcessing []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash *chainhash.Hash
			// ProcessedBy is the processedBy argument value.
			ProcessedBy string
		}
		// StartUnitOfWork holds details about calls to the StartUnitOfWork method.
		StartUnitOfWork []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// TraceToNonOrphanChain holds details about calls to the TraceToNonOrphanChain method.
		TraceToNonOrphanChain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash []byte
		}
		// UpdateBlocksStatuses holds details about calls to the UpdateBlocksStatuses method.
		UpdateBlocksStatuses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockStatusUpdates is the blockStatusUpdates argument value.
			BlockStatusUpdates []store.BlockStatusUpdate
		}
		// UpsertBlock holds details about calls to the UpsertBlock method.
		UpsertBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Block is the block argument value.
			Block *blocktx_api.Block
		}
		// UpsertBlockTransactions holds details about calls to the UpsertBlockTransactions method.
		UpsertBlockTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockID is the blockID argument value.
			BlockID uint64
			// TxsWithMerklePaths is the txsWithMerklePaths argument value.
			TxsWithMerklePaths []store.TxWithMerklePath
		}
		// VerifyMerkleRoots holds details about calls to the VerifyMerkleRoots method.
		VerifyMerkleRoots []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// MerkleRoots is the merkleRoots argument value.
			MerkleRoots []*blocktx_api.MerkleRootVerificationRequest
			// MaxAllowedBlockHeightMismatch is the maxAllowedBlockHeightMismatch argument value.
			MaxAllowedBlockHeightMismatch int
		}
		// WriteLockBlocksTable holds details about calls to the WriteLockBlocksTable method.
		WriteLockBlocksTable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockClearBlocktxTable                  sync.RWMutex
	lockClose                              sync.RWMutex
	lockCommit                             sync.RWMutex
	lockDelBlockProcessing                 sync.RWMutex
	lockGetBlock                           sync.RWMutex
	lockGetBlockByHeight                   sync.RWMutex
	lockGetBlockGaps                       sync.RWMutex
	lockGetBlockHashesProcessingInProgress sync.RWMutex
	lockGetChainTip                        sync.RWMutex
	lockGetLongestChainFromHeight          sync.RWMutex
	lockGetMinedTransactions               sync.RWMutex
	lockGetOrphanedChainUpFromHash         sync.RWMutex
	lockGetRegisteredTxsByBlockHashes      sync.RWMutex
	lockGetStaleChainBackFromHash          sync.RWMutex
	lockMarkBlockAsDone                    sync.RWMutex
	lockPing                               sync.RWMutex
	lockRegisterTransactions               sync.RWMutex
	lockRollback                           sync.RWMutex
	lockSetBlockProcessing                 sync.RWMutex
	lockStartUnitOfWork                    sync.RWMutex
	lockTraceToNonOrphanChain              sync.RWMutex
	lockUpdateBlocksStatuses               sync.RWMutex
	lockUpsertBlock                        sync.RWMutex
	lockUpsertBlockTransactions            sync.RWMutex
	lockVerifyMerkleRoots                  sync.RWMutex
	lockWriteLockBlocksTable               sync.RWMutex
}

// ClearBlocktxTable calls ClearBlocktxTableFunc.
func (mock *UnitOfWorkMock) ClearBlocktxTable(ctx context.Context, retentionDays int32, table string) (*blocktx_api.RowsAffectedResponse, error) {
	if mock.ClearBlocktxTableFunc == nil {
		panic("UnitOfWorkMock.ClearBlocktxTableFunc: method is nil but UnitOfWork.ClearBlocktxTable was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		RetentionDays int32
		Table         string
	}{
		Ctx:           ctx,
		RetentionDays: retentionDays,
		Table:         table,
	}
	mock.lockClearBlocktxTable.Lock()
	mock.calls.ClearBlocktxTable = append(mock.calls.ClearBlocktxTable, callInfo)
	mock.lockClearBlocktxTable.Unlock()
	return mock.ClearBlocktxTableFunc(ctx, retentionDays, table)
}

// ClearBlocktxTableCalls gets all the calls that were made to ClearBlocktxTable.
// Check the length with:
//
//	len(mockedUnitOfWork.ClearBlocktxTableCalls())
func (mock *UnitOfWorkMock) ClearBlocktxTableCalls() []struct {
	Ctx           context.Context
	RetentionDays int32
	Table         string
} {
	var calls []struct {
		Ctx           context.Context
		RetentionDays int32
		Table         string
	}
	mock.lockClearBlocktxTable.RLock()
	calls = mock.calls.ClearBlocktxTable
	mock.lockClearBlocktxTable.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *UnitOfWorkMock) Close() error {
	if mock.CloseFunc == nil {
		panic("UnitOfWorkMock.CloseFunc: method is nil but UnitOfWork.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedUnitOfWork.CloseCalls())
func (mock *UnitOfWorkMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *UnitOfWorkMock) Commit() error {
	if mock.CommitFunc == nil {
		panic("UnitOfWorkMock.CommitFunc: method is nil but UnitOfWork.Commit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc()
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedUnitOfWork.CommitCalls())
func (mock *UnitOfWorkMock) CommitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// DelBlockProcessing calls DelBlockProcessingFunc.
func (mock *UnitOfWorkMock) DelBlockProcessing(ctx context.Context, hash *chainhash.Hash, processedBy string) (int64, error) {
	if mock.DelBlockProcessingFunc == nil {
		panic("UnitOfWorkMock.DelBlockProcessingFunc: method is nil but UnitOfWork.DelBlockProcessing was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Hash        *chainhash.Hash
		ProcessedBy string
	}{
		Ctx:         ctx,
		Hash:        hash,
		ProcessedBy: processedBy,
	}
	mock.lockDelBlockProcessing.Lock()
	mock.calls.DelBlockProcessing = append(mock.calls.DelBlockProcessing, callInfo)
	mock.lockDelBlockProcessing.Unlock()
	return mock.DelBlockProcessingFunc(ctx, hash, processedBy)
}

// DelBlockProcessingCalls gets all the calls that were made to DelBlockProcessing.
// Check the length with:
//
//	len(mockedUnitOfWork.DelBlockProcessingCalls())
func (mock *UnitOfWorkMock) DelBlockProcessingCalls() []struct {
	Ctx         context.Context
	Hash        *chainhash.Hash
	ProcessedBy string
} {
	var calls []struct {
		Ctx         context.Context
		Hash        *chainhash.Hash
		ProcessedBy string
	}
	mock.lockDelBlockProcessing.RLock()
	calls = mock.calls.DelBlockProcessing
	mock.lockDelBlockProcessing.RUnlock()
	return calls
}

// GetBlock calls GetBlockFunc.
func (mock *UnitOfWorkMock) GetBlock(ctx context.Context, hash *chainhash.Hash) (*blocktx_api.Block, error) {
	if mock.GetBlockFunc == nil {
		panic("UnitOfWorkMock.GetBlockFunc: method is nil but UnitOfWork.GetBlock was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash *chainhash.Hash
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockGetBlock.Lock()
	mock.calls.GetBlock = append(mock.calls.GetBlock, callInfo)
	mock.lockGetBlock.Unlock()
	return mock.GetBlockFunc(ctx, hash)
}

// GetBlockCalls gets all the calls that were made to GetBlock.
// Check the length with:
//
//	len(mockedUnitOfWork.GetBlockCalls())
func (mock *UnitOfWorkMock) GetBlockCalls() []struct {
	Ctx  context.Context
	Hash *chainhash.Hash
} {
	var calls []struct {
		Ctx  context.Context
		Hash *chainhash.Hash
	}
	mock.lockGetBlock.RLock()
	calls = mock.calls.GetBlock
	mock.lockGetBlock.RUnlock()
	return calls
}

// GetBlockByHeight calls GetBlockByHeightFunc.
func (mock *UnitOfWorkMock) GetBlockByHeight(ctx context.Context, height uint64) (*blocktx_api.Block, error) {
	if mock.GetBlockByHeightFunc == nil {
		panic("UnitOfWorkMock.GetBlockByHeightFunc: method is nil but UnitOfWork.GetBlockByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height uint64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockGetBlockByHeight.Lock()
	mock.calls.GetBlockByHeight = append(mock.calls.GetBlockByHeight, callInfo)
	mock.lockGetBlockByHeight.Unlock()
	return mock.GetBlockByHeightFunc(ctx, height)
}

// GetBlockByHeightCalls gets all the calls that were made to GetBlockByHeight.
// Check the length with:
//
//	len(mockedUnitOfWork.GetBlockByHeightCalls())
func (mock *UnitOfWorkMock) GetBlockByHeightCalls() []struct {
	Ctx    context.Context
	Height uint64
} {
	var calls []struct {
		Ctx    context.Context
		Height uint64
	}
	mock.lockGetBlockByHeight.RLock()
	calls = mock.calls.GetBlockByHeight
	mock.lockGetBlockByHeight.RUnlock()
	return calls
}

// GetBlockGaps calls GetBlockGapsFunc.
func (mock *UnitOfWorkMock) GetBlockGaps(ctx context.Context, heightRange int) ([]*store.BlockGap, error) {
	if mock.GetBlockGapsFunc == nil {
		panic("UnitOfWorkMock.GetBlockGapsFunc: method is nil but UnitOfWork.GetBlockGaps was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		HeightRange int
	}{
		Ctx:         ctx,
		HeightRange: heightRange,
	}
	mock.lockGetBlockGaps.Lock()
	mock.calls.GetBlockGaps = append(mock.calls.GetBlockGaps, callInfo)
	mock.lockGetBlockGaps.Unlock()
	return mock.GetBlockGapsFunc(ctx, heightRange)
}

// GetBlockGapsCalls gets all the calls that were made to GetBlockGaps.
// Check the length with:
//
//	len(mockedUnitOfWork.GetBlockGapsCalls())
func (mock *UnitOfWorkMock) GetBlockGapsCalls() []struct {
	Ctx         context.Context
	HeightRange int
} {
	var calls []struct {
		Ctx         context.Context
		HeightRange int
	}
	mock.lockGetBlockGaps.RLock()
	calls = mock.calls.GetBlockGaps
	mock.lockGetBlockGaps.RUnlock()
	return calls
}

// GetBlockHashesProcessingInProgress calls GetBlockHashesProcessingInProgressFunc.
func (mock *UnitOfWorkMock) GetBlockHashesProcessingInProgress(ctx context.Context, processedBy string) ([]*chainhash.Hash, error) {
	if mock.GetBlockHashesProcessingInProgressFunc == nil {
		panic("UnitOfWorkMock.GetBlockHashesProcessingInProgressFunc: method is nil but UnitOfWork.GetBlockHashesProcessingInProgress was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ProcessedBy string
	}{
		Ctx:         ctx,
		ProcessedBy: processedBy,
	}
	mock.lockGetBlockHashesProcessingInProgress.Lock()
	mock.calls.GetBlockHashesProcessingInProgress = append(mock.calls.GetBlockHashesProcessingInProgress, callInfo)
	mock.lockGetBlockHashesProcessingInProgress.Unlock()
	return mock.GetBlockHashesProcessingInProgressFunc(ctx, processedBy)
}

// GetBlockHashesProcessingInProgressCalls gets all the calls that were made to GetBlockHashesProcessingInProgress.
// Check the length with:
//
//	len(mockedUnitOfWork.GetBlockHashesProcessingInProgressCalls())
func (mock *UnitOfWorkMock) GetBlockHashesProcessingInProgressCalls() []struct {
	Ctx         context.Context
	ProcessedBy string
} {
	var calls []struct {
		Ctx         context.Context
		ProcessedBy string
	}
	mock.lockGetBlockHashesProcessingInProgress.RLock()
	calls = mock.calls.GetBlockHashesProcessingInProgress
	mock.lockGetBlockHashesProcessingInProgress.RUnlock()
	return calls
}

// GetChainTip calls GetChainTipFunc.
func (mock *UnitOfWorkMock) GetChainTip(ctx context.Context) (*blocktx_api.Block, error) {
	if mock.GetChainTipFunc == nil {
		panic("UnitOfWorkMock.GetChainTipFunc: method is nil but UnitOfWork.GetChainTip was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetChainTip.Lock()
	mock.calls.GetChainTip = append(mock.calls.GetChainTip, callInfo)
	mock.lockGetChainTip.Unlock()
	return mock.GetChainTipFunc(ctx)
}

// GetChainTipCalls gets all the calls that were made to GetChainTip.
// Check the length with:
//
//	len(mockedUnitOfWork.GetChainTipCalls())
func (mock *UnitOfWorkMock) GetChainTipCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetChainTip.RLock()
	calls = mock.calls.GetChainTip
	mock.lockGetChainTip.RUnlock()
	return calls
}

// GetLongestChainFromHeight calls GetLongestChainFromHeightFunc.
func (mock *UnitOfWorkMock) GetLongestChainFromHeight(ctx context.Context, height uint64) ([]*blocktx_api.Block, error) {
	if mock.GetLongestChainFromHeightFunc == nil {
		panic("UnitOfWorkMock.GetLongestChainFromHeightFunc: method is nil but UnitOfWork.GetLongestChainFromHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height uint64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockGetLongestChainFromHeight.Lock()
	mock.calls.GetLongestChainFromHeight = append(mock.calls.GetLongestChainFromHeight, callInfo)
	mock.lockGetLongestChainFromHeight.Unlock()
	return mock.GetLongestChainFromHeightFunc(ctx, height)
}

// GetLongestChainFromHeightCalls gets all the calls that were made to GetLongestChainFromHeight.
// Check the length with:
//
//	len(mockedUnitOfWork.GetLongestChainFromHeightCalls())
func (mock *UnitOfWorkMock) GetLongestChainFromHeightCalls() []struct {
	Ctx    context.Context
	Height uint64
} {
	var calls []struct {
		Ctx    context.Context
		Height uint64
	}
	mock.lockGetLongestChainFromHeight.RLock()
	calls = mock.calls.GetLongestChainFromHeight
	mock.lockGetLongestChainFromHeight.RUnlock()
	return calls
}

// GetMinedTransactions calls GetMinedTransactionsFunc.
func (mock *UnitOfWorkMock) GetMinedTransactions(ctx context.Context, hashes [][]byte, onlyLongestChain bool) ([]store.TransactionBlock, error) {
	if mock.GetMinedTransactionsFunc == nil {
		panic("UnitOfWorkMock.GetMinedTransactionsFunc: method is nil but UnitOfWork.GetMinedTransactions was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		Hashes           [][]byte
		OnlyLongestChain bool
	}{
		Ctx:              ctx,
		Hashes:           hashes,
		OnlyLongestChain: onlyLongestChain,
	}
	mock.lockGetMinedTransactions.Lock()
	mock.calls.GetMinedTransactions = append(mock.calls.GetMinedTransactions, callInfo)
	mock.lockGetMinedTransactions.Unlock()
	return mock.GetMinedTransactionsFunc(ctx, hashes, onlyLongestChain)
}

// GetMinedTransactionsCalls gets all the calls that were made to GetMinedTransactions.
// Check the length with:
//
//	len(mockedUnitOfWork.GetMinedTransactionsCalls())
func (mock *UnitOfWorkMock) GetMinedTransactionsCalls() []struct {
	Ctx              context.Context
	Hashes           [][]byte
	OnlyLongestChain bool
} {
	var calls []struct {
		Ctx              context.Context
		Hashes           [][]byte
		OnlyLongestChain bool
	}
	mock.lockGetMinedTransactions.RLock()
	calls = mock.calls.GetMinedTransactions
	mock.lockGetMinedTransactions.RUnlock()
	return calls
}

// GetOrphanedChainUpFromHash calls GetOrphanedChainUpFromHashFunc.
func (mock *UnitOfWorkMock) GetOrphanedChainUpFromHash(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error) {
	if mock.GetOrphanedChainUpFromHashFunc == nil {
		panic("UnitOfWorkMock.GetOrphanedChainUpFromHashFunc: method is nil but UnitOfWork.GetOrphanedChainUpFromHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash []byte
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockGetOrphanedChainUpFromHash.Lock()
	mock.calls.GetOrphanedChainUpFromHash = append(mock.calls.GetOrphanedChainUpFromHash, callInfo)
	mock.lockGetOrphanedChainUpFromHash.Unlock()
	return mock.GetOrphanedChainUpFromHashFunc(ctx, hash)
}

// GetOrphanedChainUpFromHashCalls gets all the calls that were made to GetOrphanedChainUpFromHash.
// Check the length with:
//
//	len(mockedUnitOfWork.GetOrphanedChainUpFromHashCalls())
func (mock *UnitOfWorkMock) GetOrphanedChainUpFromHashCalls() []struct {
	Ctx  context.Context
	Hash []byte
} {
	var calls []struct {
		Ctx  context.Context
		Hash []byte
	}
	mock.lockGetOrphanedChainUpFromHash.RLock()
	calls = mock.calls.GetOrphanedChainUpFromHash
	mock.lockGetOrphanedChainUpFromHash.RUnlock()
	return calls
}

// GetRegisteredTxsByBlockHashes calls GetRegisteredTxsByBlockHashesFunc.
func (mock *UnitOfWorkMock) GetRegisteredTxsByBlockHashes(ctx context.Context, blockHashes [][]byte) ([]store.TransactionBlock, error) {
	if mock.GetRegisteredTxsByBlockHashesFunc == nil {
		panic("UnitOfWorkMock.GetRegisteredTxsByBlockHashesFunc: method is nil but UnitOfWork.GetRegisteredTxsByBlockHashes was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		BlockHashes [][]byte
	}{
		Ctx:         ctx,
		BlockHashes: blockHashes,
	}
	mock.lockGetRegisteredTxsByBlockHashes.Lock()
	mock.calls.GetRegisteredTxsByBlockHashes = append(mock.calls.GetRegisteredTxsByBlockHashes, callInfo)
	mock.lockGetRegisteredTxsByBlockHashes.Unlock()
	return mock.GetRegisteredTxsByBlockHashesFunc(ctx, blockHashes)
}

// GetRegisteredTxsByBlockHashesCalls gets all the calls that were made to GetRegisteredTxsByBlockHashes.
// Check the length with:
//
//	len(mockedUnitOfWork.GetRegisteredTxsByBlockHashesCalls())
func (mock *UnitOfWorkMock) GetRegisteredTxsByBlockHashesCalls() []struct {
	Ctx         context.Context
	BlockHashes [][]byte
} {
	var calls []struct {
		Ctx         context.Context
		BlockHashes [][]byte
	}
	mock.lockGetRegisteredTxsByBlockHashes.RLock()
	calls = mock.calls.GetRegisteredTxsByBlockHashes
	mock.lockGetRegisteredTxsByBlockHashes.RUnlock()
	return calls
}

// GetStaleChainBackFromHash calls GetStaleChainBackFromHashFunc.
func (mock *UnitOfWorkMock) GetStaleChainBackFromHash(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error) {
	if mock.GetStaleChainBackFromHashFunc == nil {
		panic("UnitOfWorkMock.GetStaleChainBackFromHashFunc: method is nil but UnitOfWork.GetStaleChainBackFromHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash []byte
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockGetStaleChainBackFromHash.Lock()
	mock.calls.GetStaleChainBackFromHash = append(mock.calls.GetStaleChainBackFromHash, callInfo)
	mock.lockGetStaleChainBackFromHash.Unlock()
	return mock.GetStaleChainBackFromHashFunc(ctx, hash)
}

// GetStaleChainBackFromHashCalls gets all the calls that were made to GetStaleChainBackFromHash.
// Check the length with:
//
//	len(mockedUnitOfWork.GetStaleChainBackFromHashCalls())
func (mock *UnitOfWorkMock) GetStaleChainBackFromHashCalls() []struct {
	Ctx  context.Context
	Hash []byte
} {
	var calls []struct {
		Ctx  context.Context
		Hash []byte
	}
	mock.lockGetStaleChainBackFromHash.RLock()
	calls = mock.calls.GetStaleChainBackFromHash
	mock.lockGetStaleChainBackFromHash.RUnlock()
	return calls
}

// MarkBlockAsDone calls MarkBlockAsDoneFunc.
func (mock *UnitOfWorkMock) MarkBlockAsDone(ctx context.Context, hash *chainhash.Hash, size uint64, txCount uint64) error {
	if mock.MarkBlockAsDoneFunc == nil {
		panic("UnitOfWorkMock.MarkBlockAsDoneFunc: method is nil but UnitOfWork.MarkBlockAsDone was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Hash    *chainhash.Hash
		Size    uint64
		TxCount uint64
	}{
		Ctx:     ctx,
		Hash:    hash,
		Size:    size,
		TxCount: txCount,
	}
	mock.lockMarkBlockAsDone.Lock()
	mock.calls.MarkBlockAsDone = append(mock.calls.MarkBlockAsDone, callInfo)
	mock.lockMarkBlockAsDone.Unlock()
	return mock.MarkBlockAsDoneFunc(ctx, hash, size, txCount)
}

// MarkBlockAsDoneCalls gets all the calls that were made to MarkBlockAsDone.
// Check the length with:
//
//	len(mockedUnitOfWork.MarkBlockAsDoneCalls())
func (mock *UnitOfWorkMock) MarkBlockAsDoneCalls() []struct {
	Ctx     context.Context
	Hash    *chainhash.Hash
	Size    uint64
	TxCount uint64
} {
	var calls []struct {
		Ctx     context.Context
		Hash    *chainhash.Hash
		Size    uint64
		TxCount uint64
	}
	mock.lockMarkBlockAsDone.RLock()
	calls = mock.calls.MarkBlockAsDone
	mock.lockMarkBlockAsDone.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *UnitOfWorkMock) Ping(ctx context.Context) error {
	if mock.PingFunc == nil {
		panic("UnitOfWorkMock.PingFunc: method is nil but UnitOfWork.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedUnitOfWork.PingCalls())
func (mock *UnitOfWorkMock) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// RegisterTransactions calls RegisterTransactionsFunc.
func (mock *UnitOfWorkMock) RegisterTransactions(ctx context.Context, txHashes [][]byte) ([]*chainhash.Hash, error) {
	if mock.RegisterTransactionsFunc == nil {
		panic("UnitOfWorkMock.RegisterTransactionsFunc: method is nil but UnitOfWork.RegisterTransactions was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		TxHashes [][]byte
	}{
		Ctx:      ctx,
		TxHashes: txHashes,
	}
	mock.lockRegisterTransactions.Lock()
	mock.calls.RegisterTransactions = append(mock.calls.RegisterTransactions, callInfo)
	mock.lockRegisterTransactions.Unlock()
	return mock.RegisterTransactionsFunc(ctx, txHashes)
}

// RegisterTransactionsCalls gets all the calls that were made to RegisterTransactions.
// Check the length with:
//
//	len(mockedUnitOfWork.RegisterTransactionsCalls())
func (mock *UnitOfWorkMock) RegisterTransactionsCalls() []struct {
	Ctx      context.Context
	TxHashes [][]byte
} {
	var calls []struct {
		Ctx      context.Context
		TxHashes [][]byte
	}
	mock.lockRegisterTransactions.RLock()
	calls = mock.calls.RegisterTransactions
	mock.lockRegisterTransactions.RUnlock()
	return calls
}

// Rollback calls RollbackFunc.
func (mock *UnitOfWorkMock) Rollback() error {
	if mock.RollbackFunc == nil {
		panic("UnitOfWorkMock.RollbackFunc: method is nil but UnitOfWork.Rollback was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRollback.Lock()
	mock.calls.Rollback = append(mock.calls.Rollback, callInfo)
	mock.lockRollback.Unlock()
	return mock.RollbackFunc()
}

// RollbackCalls gets all the calls that were made to Rollback.
// Check the length with:
//
//	len(mockedUnitOfWork.RollbackCalls())
func (mock *UnitOfWorkMock) RollbackCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRollback.RLock()
	calls = mock.calls.Rollback
	mock.lockRollback.RUnlock()
	return calls
}

// SetBlockProcessing calls SetBlockProcessingFunc.
func (mock *UnitOfWorkMock) SetBlockProcessing(ctx context.Context, hash *chainhash.Hash, processedBy string) (string, error) {
	if mock.SetBlockProcessingFunc == nil {
		panic("UnitOfWorkMock.SetBlockProcessingFunc: method is nil but UnitOfWork.SetBlockProcessing was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Hash        *chainhash.Hash
		ProcessedBy string
	}{
		Ctx:         ctx,
		Hash:        hash,
		ProcessedBy: processedBy,
	}
	mock.lockSetBlockProcessing.Lock()
	mock.calls.SetBlockProcessing = append(mock.calls.SetBlockProcessing, callInfo)
	mock.lockSetBlockProcessing.Unlock()
	return mock.SetBlockProcessingFunc(ctx, hash, processedBy)
}

// SetBlockProcessingCalls gets all the calls that were made to SetBlockProcessing.
// Check the length with:
//
//	len(mockedUnitOfWork.SetBlockProcessingCalls())
func (mock *UnitOfWorkMock) SetBlockProcessingCalls() []struct {
	Ctx         context.Context
	Hash        *chainhash.Hash
	ProcessedBy string
} {
	var calls []struct {
		Ctx         context.Context
		Hash        *chainhash.Hash
		ProcessedBy string
	}
	mock.lockSetBlockProcessing.RLock()
	calls = mock.calls.SetBlockProcessing
	mock.lockSetBlockProcessing.RUnlock()
	return calls
}

// StartUnitOfWork calls StartUnitOfWorkFunc.
func (mock *UnitOfWorkMock) StartUnitOfWork(ctx context.Context) (store.UnitOfWork, error) {
	if mock.StartUnitOfWorkFunc == nil {
		panic("UnitOfWorkMock.StartUnitOfWorkFunc: method is nil but UnitOfWork.StartUnitOfWork was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStartUnitOfWork.Lock()
	mock.calls.StartUnitOfWork = append(mock.calls.StartUnitOfWork, callInfo)
	mock.lockStartUnitOfWork.Unlock()
	return mock.StartUnitOfWorkFunc(ctx)
}

// StartUnitOfWorkCalls gets all the calls that were made to StartUnitOfWork.
// Check the length with:
//
//	len(mockedUnitOfWork.StartUnitOfWorkCalls())
func (mock *UnitOfWorkMock) StartUnitOfWorkCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStartUnitOfWork.RLock()
	calls = mock.calls.StartUnitOfWork
	mock.lockStartUnitOfWork.RUnlock()
	return calls
}

// TraceToNonOrphanChain calls TraceToNonOrphanChainFunc.
func (mock *UnitOfWorkMock) TraceToNonOrphanChain(ctx context.Context, hash []byte) ([]*blocktx_api.Block, error) {
	if mock.TraceToNonOrphanChainFunc == nil {
		panic("UnitOfWorkMock.TraceToNonOrphanChainFunc: method is nil but UnitOfWork.TraceToNonOrphanChain was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash []byte
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockTraceToNonOrphanChain.Lock()
	mock.calls.TraceToNonOrphanChain = append(mock.calls.TraceToNonOrphanChain, callInfo)
	mock.lockTraceToNonOrphanChain.Unlock()
	return mock.TraceToNonOrphanChainFunc(ctx, hash)
}

// TraceToNonOrphanChainCalls gets all the calls that were made to TraceToNonOrphanChain.
// Check the length with:
//
//	len(mockedUnitOfWork.TraceToNonOrphanChainCalls())
func (mock *UnitOfWorkMock) TraceToNonOrphanChainCalls() []struct {
	Ctx  context.Context
	Hash []byte
} {
	var calls []struct {
		Ctx  context.Context
		Hash []byte
	}
	mock.lockTraceToNonOrphanChain.RLock()
	calls = mock.calls.TraceToNonOrphanChain
	mock.lockTraceToNonOrphanChain.RUnlock()
	return calls
}

// UpdateBlocksStatuses calls UpdateBlocksStatusesFunc.
func (mock *UnitOfWorkMock) UpdateBlocksStatuses(ctx context.Context, blockStatusUpdates []store.BlockStatusUpdate) error {
	if mock.UpdateBlocksStatusesFunc == nil {
		panic("UnitOfWorkMock.UpdateBlocksStatusesFunc: method is nil but UnitOfWork.UpdateBlocksStatuses was just called")
	}
	callInfo := struct {
		Ctx                context.Context
		BlockStatusUpdates []store.BlockStatusUpdate
	}{
		Ctx:                ctx,
		BlockStatusUpdates: blockStatusUpdates,
	}
	mock.lockUpdateBlocksStatuses.Lock()
	mock.calls.UpdateBlocksStatuses = append(mock.calls.UpdateBlocksStatuses, callInfo)
	mock.lockUpdateBlocksStatuses.Unlock()
	return mock.UpdateBlocksStatusesFunc(ctx, blockStatusUpdates)
}

// UpdateBlocksStatusesCalls gets all the calls that were made to UpdateBlocksStatuses.
// Check the length with:
//
//	len(mockedUnitOfWork.UpdateBlocksStatusesCalls())
func (mock *UnitOfWorkMock) UpdateBlocksStatusesCalls() []struct {
	Ctx                context.Context
	BlockStatusUpdates []store.BlockStatusUpdate
} {
	var calls []struct {
		Ctx                context.Context
		BlockStatusUpdates []store.BlockStatusUpdate
	}
	mock.lockUpdateBlocksStatuses.RLock()
	calls = mock.calls.UpdateBlocksStatuses
	mock.lockUpdateBlocksStatuses.RUnlock()
	return calls
}

// UpsertBlock calls UpsertBlockFunc.
func (mock *UnitOfWorkMock) UpsertBlock(ctx context.Context, block *blocktx_api.Block) (uint64, error) {
	if mock.UpsertBlockFunc == nil {
		panic("UnitOfWorkMock.UpsertBlockFunc: method is nil but UnitOfWork.UpsertBlock was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Block *blocktx_api.Block
	}{
		Ctx:   ctx,
		Block: block,
	}
	mock.lockUpsertBlock.Lock()
	mock.calls.UpsertBlock = append(mock.calls.UpsertBlock, callInfo)
	mock.lockUpsertBlock.Unlock()
	return mock.UpsertBlockFunc(ctx, block)
}

// UpsertBlockCalls gets all the calls that were made to UpsertBlock.
// Check the length with:
//
//	len(mockedUnitOfWork.UpsertBlockCalls())
func (mock *UnitOfWorkMock) UpsertBlockCalls() []struct {
	Ctx   context.Context
	Block *blocktx_api.Block
} {
	var calls []struct {
		Ctx   context.Context
		Block *blocktx_api.Block
	}
	mock.lockUpsertBlock.RLock()
	calls = mock.calls.UpsertBlock
	mock.lockUpsertBlock.RUnlock()
	return calls
}

// UpsertBlockTransactions calls UpsertBlockTransactionsFunc.
func (mock *UnitOfWorkMock) UpsertBlockTransactions(ctx context.Context, blockID uint64, txsWithMerklePaths []store.TxWithMerklePath) error {
	if mock.UpsertBlockTransactionsFunc == nil {
		panic("UnitOfWorkMock.UpsertBlockTransactionsFunc: method is nil but UnitOfWork.UpsertBlockTransactions was just called")
	}
	callInfo := struct {
		Ctx                context.Context
		BlockID            uint64
		TxsWithMerklePaths []store.TxWithMerklePath
	}{
		Ctx:                ctx,
		BlockID:            blockID,
		TxsWithMerklePaths: txsWithMerklePaths,
	}
	mock.lockUpsertBlockTransactions.Lock()
	mock.calls.UpsertBlockTransactions = append(mock.calls.UpsertBlockTransactions, callInfo)
	mock.lockUpsertBlockTransactions.Unlock()
	return mock.UpsertBlockTransactionsFunc(ctx, blockID, txsWithMerklePaths)
}

// UpsertBlockTransactionsCalls gets all the calls that were made to UpsertBlockTransactions.
// Check the length with:
//
//	len(mockedUnitOfWork.UpsertBlockTransactionsCalls())
func (mock *UnitOfWorkMock) UpsertBlockTransactionsCalls() []struct {
	Ctx                context.Context
	BlockID            uint64
	TxsWithMerklePaths []store.TxWithMerklePath
} {
	var calls []struct {
		Ctx                context.Context
		BlockID            uint64
		TxsWithMerklePaths []store.TxWithMerklePath
	}
	mock.lockUpsertBlockTransactions.RLock()
	calls = mock.calls.UpsertBlockTransactions
	mock.lockUpsertBlockTransactions.RUnlock()
	return calls
}

// VerifyMerkleRoots calls VerifyMerkleRootsFunc.
func (mock *UnitOfWorkMock) VerifyMerkleRoots(ctx context.Context, merkleRoots []*blocktx_api.MerkleRootVerificationRequest, maxAllowedBlockHeightMismatch int) (*blocktx_api.MerkleRootVerificationResponse, error) {
	if mock.VerifyMerkleRootsFunc == nil {
		panic("UnitOfWorkMock.VerifyMerkleRootsFunc: method is nil but UnitOfWork.VerifyMerkleRoots was just called")
	}
	callInfo := struct {
		Ctx                           context.Context
		MerkleRoots                   []*blocktx_api.MerkleRootVerificationRequest
		MaxAllowedBlockHeightMismatch int
	}{
		Ctx:                           ctx,
		MerkleRoots:                   merkleRoots,
		MaxAllowedBlockHeightMismatch: maxAllowedBlockHeightMismatch,
	}
	mock.lockVerifyMerkleRoots.Lock()
	mock.calls.VerifyMerkleRoots = append(mock.calls.VerifyMerkleRoots, callInfo)
	mock.lockVerifyMerkleRoots.Unlock()
	return mock.VerifyMerkleRootsFunc(ctx, merkleRoots, maxAllowedBlockHeightMismatch)
}

// VerifyMerkleRootsCalls gets all the calls that were made to VerifyMerkleRoots.
// Check the length with:
//
//	len(mockedUnitOfWork.VerifyMerkleRootsCalls())
func (mock *UnitOfWorkMock) VerifyMerkleRootsCalls() []struct {
	Ctx                           context.Context
	MerkleRoots                   []*blocktx_api.MerkleRootVerificationRequest
	MaxAllowedBlockHeightMismatch int
} {
	var calls []struct {
		Ctx                           context.Context
		MerkleRoots                   []*blocktx_api.MerkleRootVerificationRequest
		MaxAllowedBlockHeightMismatch int
	}
	mock.lockVerifyMerkleRoots.RLock()
	calls = mock.calls.VerifyMerkleRoots
	mock.lockVerifyMerkleRoots.RUnlock()
	return calls
}

// WriteLockBlocksTable calls WriteLockBlocksTableFunc.
func (mock *UnitOfWorkMock) WriteLockBlocksTable(ctx context.Context) error {
	if mock.WriteLockBlocksTableFunc == nil {
		panic("UnitOfWorkMock.WriteLockBlocksTableFunc: method is nil but UnitOfWork.WriteLockBlocksTable was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWriteLockBlocksTable.Lock()
	mock.calls.WriteLockBlocksTable = append(mock.calls.WriteLockBlocksTable, callInfo)
	mock.lockWriteLockBlocksTable.Unlock()
	return mock.WriteLockBlocksTableFunc(ctx)
}

// WriteLockBlocksTableCalls gets all the calls that were made to WriteLockBlocksTable.
// Check the length with:
//
//	len(mockedUnitOfWork.WriteLockBlocksTableCalls())
func (mock *UnitOfWorkMock) WriteLockBlocksTableCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWriteLockBlocksTable.RLock()
	calls = mock.calls.WriteLockBlocksTable
	mock.lockWriteLockBlocksTable.RUnlock()
	return calls
}
